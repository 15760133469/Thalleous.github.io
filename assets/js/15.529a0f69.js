(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{461:function(e,t,v){"use strict";v.r(t);var r=v(2),_=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"},[e._v("说明")]),t("p",[e._v("这是js基础的Promise模块的摘要内容，"),t("code",[e._v("vuepress")]),e._v("提供的语法块")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.bilibili.com/video/BV1Tm4y1h7SY/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise的实现和讲解视频"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"promise模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise模块"}},[e._v("#")]),e._v(" Promise模块")]),e._v(" "),t("blockquote",[t("p",[e._v("事件循环是什么")])]),e._v(" "),t("p",[e._v("事件循环："),t("code",[e._v("javascript")]),e._v("的执行规则里面有个"),t("strong",[e._v("事件循环Event Loot")]),e._v("的规则，在事件循环中，异步事件会放到异步队列里面，但是异步队列里面又分为宏任务和微任务，浏览器端的宏任务一般有：")]),e._v(" "),t("p",[t("code",[e._v("script标签,setTimeout,setInterval,setImmediate,requestAnimationFrame")]),e._v("。")]),e._v(" "),t("p",[e._v("微任务有："),t("code",[e._v("MutationObserver,Promise.then catch finally")]),e._v("。")]),e._v(" "),t("p",[e._v("宏任务会阻塞浏览器的渲染进程，微任务会在宏任务结束后立即执行，在渲染之前。")]),e._v(" "),t("blockquote",[t("p",[e._v("Promise是什么")])]),e._v(" "),t("p",[e._v("Promise 是"),t("strong",[e._v("异步编程的一种解决方案")]),e._v("，比传统的解决方案回调函数和事件更合理和更强大。")]),e._v(" "),t("p",[e._v("所谓Promise，简单说就是一个"),t("strong",[e._v("容器")]),e._v("，里面保存着某个未来才会结束的事件（通常是"),t("strong",[e._v("一个异步操作")]),e._v("）"),t("strong",[e._v("的结果")]),e._v("。")]),e._v(" "),t("p",[e._v("从语法上说，Promise 是一个"),t("strong",[e._v("对象")]),e._v("，"),t("strong",[e._v("从它可以获取异步操作的消息")]),e._v("。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。")]),e._v(" "),t("p",[e._v("1.Promise的状态：pending（进行中）、fulfilled（已完成）、rejected（已拒绝）")]),e._v(" "),t("p",[e._v("2.Promise状态的变化：pending->fulfilled||pending->rejected（只能从pending开始，已经变化过的状态无法再次变化）")]),e._v(" "),t("blockquote",[t("p",[e._v("如何判断async await（以promise的思维）")])]),e._v(" "),t("p",[e._v("可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。")]),e._v(" "),t("blockquote",[t("p",[e._v("Promise和async/await各自的优缺点")])]),e._v(" "),t("p",[e._v("async/await：")]),e._v(" "),t("p",[e._v("优点：异步执行同步写法，代码阅读更加简单，且可以直接写入if内，流程相对友好优点：")]),e._v(" "),t("p",[e._v("缺点：无法单独处理promise返回的reject对象，需要借助try...catch...；await会阻塞代码，执行完成后才能执行后面的代码；try...catch...内部的变量无法传递。")]),e._v(" "),t("p",[e._v("特点：通过链式调用，直接在then中返回一个promise来进行成功之后的回调函数，用catch来做错误处理")]),e._v(" "),t("p",[e._v("Promise：")]),e._v(" "),t("p",[e._v("问题：一旦执行，就无法中途取消，链式调用多个then无法轻易的跳出来；错误无法在外部捕获；promise内部的执行很难被检测，且处于pending的情况下无法得知代码执行了到哪一步")]),e._v(" "),t("p",[e._v("特点：async是Generator函数的语法糖，async/await则将其变成同步的写法，即可以用try...catch...捕获，简洁，可读性高")]),e._v(" "),t("blockquote",[t("p",[e._v("Promise事件循环试题")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_42033567/article/details/108129645",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise相关的事件循环试题"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);