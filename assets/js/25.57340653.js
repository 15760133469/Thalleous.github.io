(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{472:function(t,v,e){"use strict";e.r(v);var _=e(2),o=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"title"},[t._v("说明")]),v("p",[t._v("这是vue模块未归类的相关问题的摘要内容，"),v("code",[t._v("vuepress")]),t._v("提供的语法块")])]),t._v(" "),v("h2",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),v("blockquote",[v("p",[t._v("vue的diff算法")])]),t._v(" "),v("p",[t._v("首先，虚拟DOM表示的是一个真实DOM的JS对象，当真实DOM改变时，会出现一个新的JS对象和一个老的JS对象。而**diff算法就是为了最快限度的找到二者的差异（DOM的新旧JS对象），最小化更新视图。**更高后触发setter，再触发dep.notify，之后在patch2个新旧虚拟DOM，进行比较，如果标签类型不同，直接替换，类型相同时，分情况，当虚拟节点不同时，直接替换。虚拟节点相同时，再分四种情况。第一种，都有文本节点，直接替换，第二种，新的有子节点，旧的没有，直接添加新的子节点，第三种情况，新的没有，旧的有子节点，删除旧的子节点。第四种情况，二者都有子节点，需要再次比对他们的子节点，使用updateChildren方法。整体策略为深度优先，同级比对。比较只会在同层级进行, 不会跨层级比较，比较的过程中，循环从两边向中间收拢。")]),t._v(" "),v("blockquote",[v("p",[t._v("ts的好处")])]),t._v(" "),v("p",[t._v("1.提供强静态类型")]),t._v(" "),v("p",[t._v("2.可以更早的发现bug(ts存在编译过程)")]),t._v(" "),v("p",[t._v("3.代码可预测(声明的类型一旦指定类型就不能再次修改)")]),t._v(" "),v("p",[t._v("4.绝大多数IDE可以对ts类型进行预测")]),t._v(" "),v("blockquote",[v("p",[t._v("什么是nextTick")])]),t._v(" "),v("p",[t._v("定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。")]),t._v(" "),v("p",[t._v("理解："),v("strong",[t._v("nextTick()，是将回调函数延迟在下一次dom更新数据后调用")]),t._v("，简单的理解是："),v("strong",[t._v("当数据更新了，在dom中渲染后，自动执行该函数。")])]),t._v(" "),v("p",[t._v("原理：Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。")]),t._v(" "),v("p",[t._v("用途：希望dom变化后操作dom，或者dom变化后更新某些引入组件的状态。")])])}),[],!1,null,null,null);v.default=o.exports}}]);